
// HERE IS WHERE THE LIST OF SECTORS IS SET TO DETERMINE THE LENGHT OF CONFIG FILES

typealias SectorName = String(length == 1 &&
    (this == SecA || this == SecB || this == SecC || this == SecD || this == SecE || this == SecF))

hidden const SecA = "A"
hidden const SecB = "B"
hidden const SecC = "C"
hidden const SecD = "D"
hidden const SecE = "E"
hidden const SecF = "F"

const allSectors:List<SectorName> = List(SecA, SecB, SecC, SecD, SecE, SecF)
// This set is used for smaller tests
hidden const testSectors:List<String> = List("A", "B")

/// ----------------   Electronic ID -------------------------
typealias EId = String

/// ----------------------------- Segments ----------------------------

// HERE IS WHERE THE NUMBER OF SEGMENTS IN A SECTOR IS SET
const FULL_SEGMENTS_PER_SECTOR = 82

const SEGMENTS_PER_SECTOR:Int = FULL_SEGMENTS_PER_SECTOR
// Number of spares is also 82
const NUMBER_SPARE_SEGMENTS = FULL_SEGMENTS_PER_SECTOR

/// For testing
hidden const TEST_SEGMENTS_PER_SECTOR = 2


// SegNum goes from 1 to 492 + 50.  A SegName is "s234"
const TOTAL_NUMBER_SEGMENTS_ON_TELESCOPE = allSectors.length * SEGMENTS_PER_SECTOR
const TOTAL_NUMBER_SEGMENTS = TOTAL_NUMBER_SEGMENTS_ON_TELESCOPE + NUMBER_SPARE_SEGMENTS

const MAX_SEGMENT_NUMBER = TOTAL_NUMBER_SEGMENTS

typealias SegmentNum = Int((n) -> n >= 1 && n <= TOTAL_NUMBER_SEGMENTS)

function toSegNum(segName: SegName): SegNum = segName.drop(SEGMENT_NAME_BASE.length).toInt()

function toSegName(segNum: SegNum): SegName = SEGMENT_NAME_BASE + segNum.toString().padStart(SEGMENT_NAME_NUM_WIDTH, "0")

hidden const SEGMENT_NAME_BASE:String = "SN-"
hidden const SEGMENT_NAME_NUM_WIDTH = 3  // The padding for segment name
const SEGMENT_NAME_LENGTH:Int = 7  // Up to SN-001

hidden const FAKE_SEGMENT_EID_ENDING = ":SegmentEId"


// An ActName is letter A and a number like a1234
typealias SegName = String((str) -> str.take(SEGMENT_NAME_BASE.length) == SEGMENT_NAME_BASE && str.length <= SEGMENT_NAME_LENGTH)

typealias SegNum = Int((n) -> n >= 1 && n <= MAX_SEGMENT_NUMBER)

x = toSegName(1)
y = toSegNum("SN-001")

// List of all cellnames based on allSectors and SEGMENTS_PER_SECTOR
function allSegmentsNameList():List<SegName> = new Dynamic {
  for (m in IntSeq(1, TOTAL_NUMBER_SEGMENTS)) {
    toSegName(m)
  }
}.toList()

///
/// -------------------------- Mirror Structure Cells -----------------------
///

// Checks that a mirror cell name has a valid sector (A-F)
const function checkSector(id: String): Boolean = allSectors.contains(id.take(1))

/// Verify that a cell name mirror number is within range (1-82)
const function checkSectorMirror(id: String): Boolean =
  id.drop(1).toInt() <= SEGMENTS_PER_SECTOR && id.drop(1).toInt() >= 1

const CELL_NAME_LENGTH:Int = 3
// A CellName is a sector and a number like A42
typealias CellName = String((str) -> checkCellName(str))
const function checkCellName(id: String): Boolean = (id.length <= CELL_NAME_LENGTH && checkSector(id) && checkSectorMirror(id))

typealias CellNumber = Int(isBetween(1, TOTAL_NUMBER_SEGMENTS))
typealias SectorCellNumber = Int(isBetween(1, SEGMENTS_PER_SECTOR))


class asCellName {
  // input parameter
  name: CellName

  /// Output parameters
  ///
  /// Returns the letter of a segmentId ("A23")
  sectorLetter: SectorName = name.take(1)

  ///
  /// The number of a sector as an Int
  ///
  sectorNumber: Int =
    allSectors.indexOf(sectorLetter) + 1

  ///
  /// The number portion of a CellName (i.e. 42 in A42)
  mirrorNumber: SectorCellNumber = name.drop(1).toInt()

  ///
  /// Absolute segment number (1-492) for a cellname
  segNum: CellNumber = (sectorNumber - 1) * SEGMENTS_PER_SECTOR + mirrorNumber

}

// Returns an object that has useful values based on the CellName (function as object pattern!)
function cellName(c: CellName):asCellName = new { name = c}

function toCellName(sector: SectorName, mirrorNumber: SectorCellNumber): CellName = sector.toUpperCase() + mirrorNumber.toString()

///
/// Returns a list of cell names for sectors and maxMirrors in each sector
function createCellNames(sectors: List<String>, maxCells: Int):List<CellName> = new Dynamic {
  for (s in sectors) {
    for (m in IntSeq(1, maxCells)) {
      //s + m.toString()
      toCellName(s, m)
    }
  }
}.toList()

// List of all cellnames based on allSectors and SEGMENTS_PER_SECTOR
hidden fixed allMirrorCellList:List<CellName> = createCellNames(allSectors, SEGMENTS_PER_SECTOR)
///
/// Returns the Cell Name for a cell number
///
function getCellNameFromNum(cellNum: Int): CellName =
  let (sector:Int = (cellNum - 1) ~/ SEGMENTS_PER_SECTOR)
    let(num:Int = cellNum % SEGMENTS_PER_SECTOR)
      allSectors[sector] + (if (num == 0) SEGMENTS_PER_SECTOR else num).toString()


///
/// -------------  Actuators ---------------------------------
///
const ACTUATORS_PER_SEGMENT:Int = 3
const ACTUATORS_ON_TELESCOPE: Int = TOTAL_NUMBER_SEGMENTS_ON_TELESCOPE * ACTUATORS_PER_SEGMENT
const NUMBER_SPARE_ACTUATORS = 50
const TOTAL_NUMBER_ACTUATORS = ACTUATORS_ON_TELESCOPE + NUMBER_SPARE_ACTUATORS
const MAX_GLOBAL_ACTUATOR_NUMBER = TOTAL_NUMBER_ACTUATORS

typealias ActNum = Int((n) -> n >= 1 && n <= MAX_GLOBAL_ACTUATOR_NUMBER)

function toActNum(actName: ActName): ActNum = actName.drop(1).toInt()

function toActName(actNum: ActNum): ActName = ACTUATOR_NAME_BASE + actNum.toString()

hidden const ACTUATOR_NAME_BASE:String = "a"
const ACTUATOR_NAME_LENGTH:Int = 5  // Up to a1626

// An ActName is letter A and a number like a1234
typealias ActName = String((str) -> str.take(1) == ACTUATOR_NAME_BASE && str.length <= ACTUATOR_NAME_LENGTH)

typealias LocalActNum = Int((n) -> n >= 1 && n <= ACTUATORS_PER_SEGMENT)



///
/// Returns a global actuator number for a SegName and a local actuator number (1-3) ActNum
function globalActuatorNumber(name: CellName, localActNum: LocalActNum): ActNum =
  let (globalSegNum = cellName(name).segNum)
    (globalSegNum - 1) * ACTUATORS_PER_SEGMENT + localActNum

///
/// Returns a local actuator number for a global actuator number
///
function localActuatorNumber(globalActuatorNumber): ActNum =
  let (mod = globalActuatorNumber % ACTUATORS_PER_SEGMENT)
    if (mod == 0) ACTUATORS_PER_SEGMENT else mod


///
/// ------------------------ Sensors ------------------------------------
///
const SENSORS_PER_SEGMENT:Int = 12
const SENSORS_PER_SECTOR:Int = SENSORS_PER_SEGMENT * SEGMENTS_PER_SECTOR
const MAX_GLOBAL_SENSOR_NUMBER = SENSORS_PER_SEGMENT * TOTAL_NUMBER_SEGMENTS

typealias SensorNum = Int((id) -> id >= 1 && id <= SENSORS_PER_SEGMENT)
typealias GlobalSensorNum = Int((id) -> id >= 1 && id <= MAX_GLOBAL_SENSOR_NUMBER)

///
/// Returns the GlobalSensorNumber (1-5904) given a segName and local Sensor Number
function globalSensorNumber(id: CellName, sensorNum: SensorNum): GlobalSensorNum =
  let (globalSegNum = cellName(id).segNum)
    (globalSegNum - 1) * SENSORS_PER_SEGMENT + sensorNum


///
/// Returns the segName for an absolute sensor number
///
function globalSensorNumberToSeg(sensorNum: Int): CellName =
  let(segInt = (sensorNum - 1) ~/ SENSORS_PER_SEGMENT)
      getCellNameFromNum(segInt + 1)

///
/// Returns a local sensor number from a global sensor number
///
function globalSensorNumberToLocalSensorNumber(sensorNum: GlobalSensorNum): SensorNum =
  let (sensInt = (sensorNum) % SENSORS_PER_SEGMENT)
    if (sensInt == 0) SENSORS_PER_SEGMENT else sensInt

///
/// Returns a Pair of SegName and local Sensor number for a global sensor number
///
function globalSensorNumberToPair(sensorNum: GlobalSensorNum): Pair<CellName, SensorNum> =
  Pair(globalSensorNumberToSeg(sensorNum), globalSensorNumberToLocalSensorNumber(sensorNum))


